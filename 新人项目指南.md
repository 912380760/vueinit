### src目录结构
- assets   
公共资源图像
- base  

- components   
公共组件
- consts   
公共常量
- directives   
自定义指令
- dell  

- filters   
全局过滤器,通过对Lodash进行了封装,并绑定到Vue全局中
- mixins   
一些公共的方法,通过build.js文件集中暴露
- mock  
mock.jS相关配置,[mock.js](http://mockjs.com/)是一个模拟数据生成器,根据数据模板生成模拟数据,模拟 Ajax 请求，生成并返回模拟数据
- plugins  
为Vue安装的插件
- services  
所有的ajax请求
- store  
vuex相关配置
- svg  
项目中的SVG图片
- themes

- utils  
通用工具
- vant  
对vant框架相关的修改
- vendor  

- views  
业务页面文件
- App.vue  
主vue文件
- boots.js  

- build.js  
暴露了filters mixins directives
- index.js
主入口js

### 依赖
- 使用[vant](https://youzan.github.io/vant/#/zh-CN/intro)作为基础的UI框架
- 项目中使用到[Lodash](https://lodash.com/docs/4.17.11),使用_符号开头,这是一个JS的通用库,包装了数组，数字，对象，字符串的一些方法.
- 项目中使用[Moment.js](https://momentjs.com)处理时间对象
- 项目已通过[postcss-pxtorem](https://github.com/cuth/postcss-pxtorem)配置PX to REM方案,会自动转换px为rem单位
- 项目中使用[vuex-router-sync](https://github.com/vuejs/vuex-router-sync)把路由对象存入store中,然后通过router中定义的meta对象来判断动态加载头部底部等.

### 接口请求
对接口请求封装了两个方法, 分别是 **bindGet** 和 **bindSave**  
具体文件在/mixins里的 service-command.js get-command.js form.js 

``` JS
this.bindGet(api, bindingData, 
  {
    callback = this.$_defaultGetCommandFunc,
    format = (data) => data,
    transferFormat = false, 
    successMessage = '',
    polling = false,
    sendingData = {},
    cache = false,
    beforeSend = (data) => data,
    action = api.name,
    afterSuccess = _.noop,
    afterFail = _.noop
  } = {}
})

this.bindSave(api, action, sendingData,
  {
    callback = this.$_defaultSendingCommandFunc,
    successMessage = '保存成功',
    beforeSend = (data) => data,
    afterSuccess = _.noop,
    afterFail = _.noop
  } = {}
})

// api 具体的axios请求对象或 mutationName字符串
// 可以按services/api规范写
// 也可以是写在store/mutation-types.js中定义 mutationName,再去创建对应的mutation,在mutation里面处理api请求和store等,这种方式等与多了一层mutation的封装

// bindingData 请求返回参数
// 返回参数会绑定回组件的data里

// callback 请求结束后的回调函数
// 请求结束不管成功还是失败都会触发
// 默认的callback($_defaultGetCommandFunc),请求成功会执行afterSuccess,失败会执行afterFail, 请求成功还会弹提示信息successMessage

// format 请求成功后对数据进行处理,并绑定到组件的this中
// 只有callback为空才会执行

// transferFormat
// 把返回参数 data.list[0] 提升到 data.list
// $_defaultGetCommandFunc => if(transferFormat) data.list = data.list[0];  data.list
// 只有callback为空才会执行

// successMessage 请求成功提示文案
// 会调用vant的$toast.success方法弹出一个轻提示框 
// $_defaultGetCommandFunc => if(transferFormat) this.$toast.success(successMessage)
// 只有callback为空才会执行

// polling ?

// sendingData 接口需要的参数
// 如果是字符串会使用组件里的this[paramsName]
// 也可以传入对象

// cache api缓存,默认不缓存

// beforeSend 请求前数据处理
// beforeSend: (data) => data,注意这里的data并不是把传入值做的一个深拷贝对象,如sendingData为字符串,修改这个data是会影响到组件的数据

// action 请求昵称
// 昵称需要组件内唯一,配合doGet({action: actionName})使用

// afterSuccess 请求成功回调
// 只有callback为空才会执行

// afterFail 失败回调
// 只有callback为空才会执行

// bindGet通过doGet({action: name})调用, bindSave通过doSave({action: name})调用 
// bindGet会把当前组件所有请求都存储到$_commands里,可以通过getAll()调用前面已经声明的所有bindGet


// 例子
// 先在services/api/user.js 里写好api
const registerApi = async ({username, password, imgCode, uuid}) => {
  const [result, data] = await apiService.post(api.USER_REGISTER, {
    username,
    password,
    imgCode,
    uuid,
  });

  return [result, data];
};

// 在views/pages/download/components/page-1.vue组件counted里声明saveForm
this.bindSave(registerApi, "saveForm", "formInline", {
  callback: ([result, data]) => {
    ...
  }
});

// 在表单提交事件onSubmit中使用
onSubmit() {
  if (
    ...
  ) {
    this.doSave({ action: "saveForm" });
  }
}
```